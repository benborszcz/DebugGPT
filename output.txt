# agent.py
```
import config
import openai
from tenacity import retry, wait_random_exponential, stop_after_attempt

# Set the API Params for OpenAI
openai.api_key = config.OPENAI_API_KEY

class Agent:
    def __init__(self, id, system: str = "You are a helpful assistant", additional_messages: list = None, functions: list = None):
        self.id = id
        self.system = system
        self.functions = functions
        if self.functions == None: 
            self.functions = []
            self.function_agent = None
        self.additional_messages = additional_messages
    
    def generate(self, messages: list, temperature=0.4, presence_penalty=0.1, frequency_penalty=0.1, max_tokens=1000):      
        local_messages = []
        local_messages.extend(messages)
        local_messages.insert(0, {"role": "system", "content": self.system})
        if self.additional_messages != None: local_messages.insert(1, self.additional_messages)
        response = self.chat_completion(local_messages)
        return response
    
    @retry(wait=wait_random_exponential(min=1, max=40), stop=stop_after_attempt(3))
    def chat_completion(self, messages: list, temperature=0.4, presence_penalty=0.1, frequency_penalty=0.1, max_tokens=1000):
        # Generate a response using the OpenAI API
        response = openai.ChatCompletion.create(
            model="gpt-3.5-turbo",
            messages=messages,
            temperature=temperature,
            presence_penalty=presence_penalty,
            frequency_penalty=frequency_penalty,
            max_tokens=max_tokens
        )

        return response
```

# agent_manager.py
```
from agent import Agent


class AgentManager:
    def __init__(self):
        self.agents = {
            "Chat": Agent("Chat"),
            "ErrorAnalysis": Agent("ErrorAnalysis", "You analyze programming error codes, identify the files invloved, and explain the error in natural language."),
            "FileRequester": Agent("FileRequester", "Given a natural language representation of a programming error code, you: request the necessary files to read to solve the error."),
            "StepPlanner": Agent("StepPlanner", "Given a natural language representation of a programming error code and the necessary files to read, you give a step by step plan to solve the problem."),
            "CodeModifier": Agent("CodeModifier", "Given a natural language representation of a programming error code, the necessary files, and a step by step plan to fix the error, you follow the steps and generate the necessary code to solve the problem. The code generated should be"),
            "ErrorComparison": Agent("ErrorComparison"),
            "Revert": Agent("Revert")
        }

    def generate(self, agent_id: str, messages: list = None):
        if messages == None : messages = []

        response = self.agents[agent_id].generate(messages=messages)

        response_message = response['choices'][0]['message'] 
        return {"role": response_message['role'], "content": response_message['content']}
```

# config.py
```
import os
from dotenv import load_dotenv

load_dotenv()

OPENAI_API_KEY = os.getenv("OPENAI_API_KEY")

DEBUG = True
```

# DEVPLAN.md
```
# DebugGPT

## Explanation of tool

Cli tool that you can call to debug your code using GPT-4

## How it will work

Give file to run
â¬‡ï¸
Generate file structure visual (folder2text)
â¬‡ï¸
Analyze Error Code
â¬‡ï¸
Select Necessary Files
â¬‡ï¸ 
Generate txt file representation (folder2text)
â¬‡ï¸
Generate code/solution to fix the problem
â¬‡ï¸
Take steps to complete solution (functions)
â¬‡ï¸
Test to see if solution fixed error
â¬‡ï¸
Return result of pass
â¬‡ï¸
Ask user if theyâ€™d like to revert
```

# function.py
```
from abc import ABC, abstractmethod

class Function(ABC):

    def __init__(self, name, instructions: str):
        '''
        Instructions must be formatted as so:

        ## Tool Name

        // General description of tool
        // - Points or further descriptions
        // -- Even more detailed descriptions of other points

        namespace Tool Name {

        // function description
        type function_name = (_: {
        // parameter 1
        input: string,
        // parameter 2
        input_2: number,
        }) => any;
        
        } // namespace Tool Name
        '''

        """
        STRUCTURE TO PUT IN INSTRUCTIONS
        {
            "name": "get_current_weather",
            "description": "Get the current weather in a given location",
            "parameters": {
                "type": "object",
                "properties": {
                    "location": {
                        "type": "string",
                        "description": "The city and state, e.g. San Francisco, CA",
                    },
                    "unit": {"type": "string", "enum": ["celsius", "fahrenheit"]},
                },
                "required": ["location"],
            },
        }
        """
        self.name = name
        self.instructions = instructions
        
    @abstractmethod
    def process_instruction(self, **kwargs) -> str:
        pass
```

# LICENSE
```
MIT License

Copyright (c) 2023 benborszcz

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

# main.py
```
from script_runner import ScriptRunner
from agent_manager import AgentManager

manager = AgentManager()


# Usage
runner = ScriptRunner('test_script.py')
output = runner.run_script()

error_analysis_output = manager.generate("ErrorAnalysis", [{"role":"user","content":output}])
error_analysis_output = 

```

# README.md
```
# DebugGPT
```

# requirements.txt
```
python-dotenv
openai
tenacity
```

# script_runner.py
```
import traceback
import runpy

class ScriptRunner:

    def __init__(self, script_path):
        self.script_path = script_path

    def run_script(self):
        try:
            runpy.run_path(self.script_path)
        except Exception as e:
            return "".join(traceback.format_exception(type(e), e, e.__traceback__))
```

# test_script.py
```
prit("Poopoo")
```

